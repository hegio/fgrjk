name: Sync & Enhance Proxy Nodes

on:
  schedule:
    - cron: '0 */3 * * *'
  workflow_dispatch:

jobs:
  sync-and-enhance:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'

    - name: Install dependencies
      run: pip install pyyaml

    - name: Download nodes file
      run: |
        if curl -L --fail --max-time 30 -o "é”‹å“¥è½¯ä»¶åº“èŠ‚ç‚¹.tmp" "https://ghfast.top/https://raw.githubusercontent.com/FGBLH/fgrjk/main/é”‹å“¥è½¯ä»¶åº“èŠ‚ç‚¹"; then
          echo "Downloaded via ghfast.top"
        elif curl -L --fail --max-time 30 -o "é”‹å“¥è½¯ä»¶åº“èŠ‚ç‚¹.tmp" "https://raw.githubusercontent.com/FGBLH/fgrjk/main/é”‹å“¥è½¯ä»¶åº“èŠ‚ç‚¹"; then
          echo "Downloaded via direct"
        else
          echo "::error::Download failed"
          exit 1
        fi
        mv "é”‹å“¥è½¯ä»¶åº“èŠ‚ç‚¹.tmp" "é”‹å“¥è½¯ä»¶åº“èŠ‚ç‚¹"

    - name: Decode and validate nodes
      run: |
        cat > process_nodes.py << 'EOF'
        import base64
        import re
        import urllib.parse

        # è¯»å–æ–‡ä»¶
        with open('é”‹å“¥è½¯ä»¶åº“èŠ‚ç‚¹', 'r', encoding='utf-8') as f:
            content = f.read()

        # å°è¯• Base64 è§£ç 
        try:
            decoded = base64.b64decode(content + '=' * (4 - len(content) % 4)).decode('utf-8')
            lines = [l.strip() for l in decoded.split('\n') if l.strip()]
        except:
            lines = [l.strip() for l in content.split('\n') if l.strip()]

        # ä¿å­˜æ˜Žæ–‡
        with open('nodes_plain.txt', 'w') as f:
            f.write('\n'.join(lines))
        
        print(f"Processed {len(lines)} lines")
        EOF
        python3 process_nodes.py

    - name: Generate valid Clash config
      run: |
        cat > generate_clash.py << 'EOF'
        import yaml
        import base64
        import json
        import urllib.parse
        import re

        def parse_vmess(link):
            """è§£æž vmess:// é“¾æŽ¥"""
            try:
                b64_data = link[8:]
                b64_data += '=' * (4 - len(b64_data) % 4)
                json_str = base64.b64decode(b64_data).decode('utf-8')
                data = json.loads(json_str)
                
                node = {
                    'name': data.get('ps', 'VMess Node'),
                    'type': 'vmess',
                    'server': data.get('add', ''),
                    'port': int(data.get('port', 443)),
                    'uuid': data.get('id', ''),
                    'alterId': int(data.get('aid', 0)),
                    'cipher': 'auto',
                    'tls': data.get('tls', '') == 'tls',
                    'network': data.get('net', 'tcp'),
                    'ws-opts': {}
                }
                
                # WebSocket é…ç½®
                if node['network'] == 'ws':
                    node['ws-opts']['path'] = data.get('path', '/')
                    if data.get('host'):
                        node['ws-opts']['headers'] = {'Host': data['host']}
                
                # è·³è¿‡æ— æ•ˆèŠ‚ç‚¹
                if not node['server'] or not node['uuid']:
                    return None
                return node
            except Exception as e:
                print(f"Parse vmess error: {e}")
                return None

        def parse_vless(link):
            """è§£æž vless:// é“¾æŽ¥"""
            try:
                # vless://uuid@server:port?params#name
                match = re.match(r'vless://([^@]+)@([^:]+):(\d+)\?([^#]+)#(.+)', link)
                if not match:
                    # å°è¯•ä¸å¸¦ name çš„æ ¼å¼
                    match = re.match(r'vless://([^@]+)@([^:]+):(\d+)\?(.+)', link)
                    if match:
                        uuid, server, port, params = match.groups()
                        name = f"VLESS-{server}"
                    else:
                        return None
                else:
                    uuid, server, port, params, name = match.groups()
                
                query = urllib.parse.parse_qs(params)
                
                node = {
                    'name': urllib.parse.unquote(name),
                    'type': 'vless',
                    'server': server,
                    'port': int(port),
                    'uuid': uuid,
                    'tls': query.get('security', [''])[0] == 'tls',
                    'network': query.get('type', ['tcp'])[0],
                    'udp': True
                }
                
                # XTLS/Flow æ”¯æŒ
                flow = query.get('flow', [''])[0]
                if flow:
                    node['flow'] = flow
                
                # WebSocket / gRPC
                if node['network'] == 'ws':
                    node['ws-opts'] = {
                        'path': query.get('path', ['/'])[0],
                        'headers': {'Host': query.get('sni', [server])[0]}
                    }
                
                return node
            except Exception as e:
                print(f"Parse vless error: {e}")
                return None

        def parse_trojan(link):
            """è§£æž trojan:// é“¾æŽ¥"""
            try:
                # trojan://password@server:port?params#name
                match = re.match(r'trojan://([^@]+)@([^:]+):(\d+)\?([^#]+)#(.+)', link)
                if not match:
                    match = re.match(r'trojan://([^@]+)@([^:]+):(\d+)#(.+)', link)
                    if match:
                        password, server, port, name = match.groups()
                        params = ''
                    else:
                        return None
                else:
                    password, server, port, params, name = match.groups()
                
                query = urllib.parse.parse_qs(params) if params else {}
                
                node = {
                    'name': urllib.parse.unquote(name),
                    'type': 'trojan',
                    'server': server,
                    'port': int(port),
                    'password': password,
                    'tls': True,
                    'sni': query.get('sni', [server])[0],
                    'udp': True
                }
                
                # è·³è¿‡æ— æ•ˆ
                if not node['server'] or not node['password']:
                    return None
                return node
            except Exception as e:
                print(f"Parse trojan error: {e}")
                return None

        def parse_ss(link):
            """è§£æž ss:// é“¾æŽ¥"""
            try:
                # ss://method:password@server:port#name
                # æˆ– ss://base64(method:password)@server:port#name
                if link.startswith('ss://'):
                    content = link[5:]
                
                # æ£€æŸ¥æ˜¯å¦æ˜¯ base64 ç¼–ç 
                if '@' not in content and content.startswith('Ym'):
                    # base64 ç¼–ç çš„æ—§æ ¼å¼
                    parts = content.split('@')
                    if len(parts) == 2:
                        b64 = parts[0] + '=' * (4 - len(parts[0]) % 4)
                        method_pass = base64.b64decode(b64).decode('utf-8')
                        server_part = parts[1]
                    else:
                        return None
                else:
                    # æ–°æ ¼å¼ï¼šç›´æŽ¥è§£æž
                    match = re.match(r'(.+?)@(.+)', content)
                    if not match:
                        return None
                    method_pass = urllib.parse.unquote(match.group(1))
                    server_part = match.group(2)
                
                method, password = method_pass.split(':', 1)
                
                # è§£æž server:port#name
                if '#' in server_part:
                    server_port, name = server_part.split('#', 1)
                    name = urllib.parse.unquote(name)
                else:
                    server_port = server_part
                    name = f"SS-{server_part.split(':')[0]}"
                
                server, port = server_port.split(':')
                
                node = {
                    'name': name,
                    'type': 'ss',
                    'server': server,
                    'port': int(port),
                    'cipher': method,
                    'password': password,
                    'udp': True
                }
                return node
            except Exception as e:
                print(f"Parse ss error: {e}")
                return None

        # è¯»å–æ˜Žæ–‡èŠ‚ç‚¹
        with open('nodes_plain.txt', 'r') as f:
            lines = f.readlines()

        proxies = []
        errors = []
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
            
            node = None
            if line.startswith('vmess://'):
                node = parse_vmess(line)
            elif line.startswith('vless://'):
                node = parse_vless(line)
            elif line.startswith('trojan://'):
                node = parse_trojan(line)
            elif line.startswith('ss://'):
                node = parse_ss(line)
            
            if node:
                # åŽ»é‡ï¼šæ£€æŸ¥æ˜¯å¦å·²æœ‰ç›¸åŒ name
                existing = [p for p in proxies if p['name'] == node['name']]
                if not existing:
                    proxies.append(node)
                else:
                    node['name'] = node['name'] + '-2'
                    proxies.append(node)
            else:
                errors.append(line[:50] + '...' if len(line) > 50 else line)

        print(f"âœ“ Successfully parsed {len(proxies)} nodes")
        print(f"âœ— Failed to parse {len(errors)} lines")

        # ç”Ÿæˆ Clash é…ç½®
        clash_config = {
            'mixed-port': 7890,
            'allow-lan': True,
            'mode': 'rule',
            'log-level': 'info',
            'external-controller': '0.0.0.0:9090',
            'dns': {
                'enable': True,
                'nameserver': ['114.114.114.114', '8.8.8.8']
            },
            'proxies': proxies,
            'proxy-groups': [
                {
                    'name': 'Auto',
                    'type': 'select',
                    'proxies': [p['name'] for p in proxies[:10]]  # æœ€å¤šå‰10ä¸ª
                },
                {
                    'name': 'LoadBalance',
                    'type': 'load-balance',
                    'strategy': 'consistent-hashing',
                    'proxies': [p['name'] for p in proxies],
                    'url': 'http://www.gstatic.com/generate_204',
                    'interval': 300
                }
            ],
            'rules': [
                'DOMAIN-SUFFIX,google.com,Auto',
                'DOMAIN-SUFFIX,youtube.com,Auto',
                'DOMAIN-KEYWORD,google,Auto',
                'MATCH,DIRECT'
            ]
        }

        with open('nodes_clash.yaml', 'w', encoding='utf-8') as f:
            yaml.dump(clash_config, f, default_flow_style=False, allow_unicode=True)

        print("Generated nodes_clash.yaml")
        
        # åŒæ—¶ç”Ÿæˆé€‚åˆ Clash Verge/CFW çš„ config.yaml
        with open('config.yaml', 'w', encoding='utf-8') as f:
            yaml.dump(clash_config, f, default_flow_style=False, allow_unicode=True)
            
        EOF
        
        python3 generate_clash.py

    - name: Generate Sing-box config
      run: |
        cat > generate_singbox.py << 'EOF'
        import json
        
        # è¯»å–æ˜Žæ–‡èŠ‚ç‚¹
        with open('nodes_plain.txt', 'r') as f:
            lines = [l.strip() for l in f if l.strip()]
        
        outbounds = [{"type": "direct", "tag": "direct"}]
        
        for i, line in enumerate(lines):
            if line.startswith(('vmess://', 'vless://', 'trojan://', 'ss://')):
                outbounds.append({
                    "type": "selector",
                    "tag": f"node_{i}",
                    "outbounds": ["direct"]
                })
        
        config = {
            "log": {"level": "info"},
            "dns": {"servers": [{"address": "8.8.8.8"}]},
            "outbounds": outbounds
        }
        
        with open('nodes_singbox.json', 'w') as f:
            json.dump(config, f, indent=2)
        
        print("Generated nodes_singbox.json")
        EOF
        
        python3 generate_singbox.py

    - name: Commit and push
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        
        git add -A
        
        if git diff --staged --quiet; then
          echo "No changes"
        else
          git commit -m "ðŸ”„ Sync: Updated nodes with valid Clash config [$(date '+%Y-%m-%d %H:%M')]"
          git push
          echo "âœ… Done"
        fi
